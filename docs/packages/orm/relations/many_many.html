<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="./../../../assets/css/combined.css?20170912">
	<link rel="shortcut icon" href="./../../../favicon.ico" />
	<script src="https://www.google.com/jsapi" type="text/javascript"></script>
	<script type="text/javascript">
		var path = './../../../';
	</script>
	<script src="./../../../assets/js/combined.js?20170912"></script>
	<title>Many to Many - Relations - Orm Package - FuelPHP Documentation</title>
</head>
<body>
	<div id="container">
		<header id="header">
			<div class="table">
				<div id="cse">
					<gcse:searchbox-only newWindow="true"></gcse:searchbox-only>
				</div>
				<h1>
					<a href="https://fuelphp.com"><img height="37px" width="147px" src="./../../../assets/img/fuel.png" /></a>
					<strong>Documentation</strong>
				</h1>
			</div>
			<nav>
				<div class="clear"></div>
			</nav>
			<a href="#" id="toc_handle">table of contents</a>
			<div class="clear"></div>
		</header>

		<div id="main">
			<h2>Orm</h2>

			<p>Orm is short for <a href="http://en.wikipedia.org/wiki/Object_relational_mapper" target="_blank">Object
				Relational Mapper</a> which does 2 things: it maps your database table rows to objects and it allows you
				to establish relations between those objects.<br />
				It follows closely the <a href="http://en.wikipedia.org/wiki/Active_record_pattern" target="_blank">
				Active Record Pattern</a>, but was also influenced by other systems.</p>

			<section>
				<h2 id="many_many">Relations: Many to Many</h2>

				<p>Specifies a many-to-many relationship to another model. The target model will have the same type of
					relationship in the other direction. To allow for these relations you need a table in between with just
					the 2 IDs from both sides of the relation as dual-primary key.</p>

				<h4>Keeping values with the relationship</h4>

				<p>If you need to save values with the relationship table you don't want to use ManyMany but create a model
					in between instead which belongs to both sides of what you would otherwise call the ManyMany
					relationship. It is described under "<a href="intro.html#usage_nested_rels">Usage with nested
					relationships</a> how you can fetch all this.</p>

				<h3>Configuration Options</h3>

				<p>ManyMany relations have three additional configuration options compared to the others. All of these
					are still optional when using the most common naming conventions.</p>

				<table class="config">
					<tbody>
						<tr class="header">
							<th>Option</th>
							<th>Default</th>
							<th>Notes</th>
						</tr>
						<tr>
							<th>table_through</th>
							<td>Calculated from model_to and model_from alphabetically ordered</td>
							<td>This is the table that connects the 2 models and has both their IDs in it. For 2 models
								like Model_User and Model_Post it will be named posts_users by default (both plural).</td>
						</tr>
						<tr>
							<th>key_through_from</th>
							<td>Calculated from the current model name</td>
							<td>The key that matches the current model's primary key. If your current model is Model_Post
								this will be post_id by default</td>
						</tr>
						<tr>
							<th>key_through_to</th>
							<td>Calculated from the related model name</td>
							<td>The key that matches the related model's primary key. If your related model is Model_User
								this will be user_id by default</td>
						</tr>
					</tbody>
				</table>

				<h4>Ordering on a column in the through table</h4>

				<p>
					In addition to the normal default order you can define in a relationship definition, you can also
					define now the records from <kbd>table_through</kbd> need to be ordered:

				<pre class="php"><code>protected static $_many_many = array(
	'users' => array(
		'table_through' => 'posts_users', 	// both models plural without prefix in alphabetical order
		'conditions' => array(
		   'order_by' => array(
				'posts_users.status' => 'ASC'	// define custom through table ordering
			),
		),
	)
);
// other fields that may be required have been ommitted for this example</code></pre>

				<p>
					The conditions array can also contain where clauses, which will act as a permanent filter on the related table results.
				</p>

				<h3>Example</h3>

				<p>Let's say we have a model <kbd>Model_Post</kbd> and it <em>has many and belongs to many</em>
					<kbd>Model_User</kbd>s. The ID of the Model_Post is along with the ID of the Model_User in a table
					called <kbd>posts_users</kbd> (default order is alphabetical). That table has just 2 columns:
					<kbd>post_id</kbd> and <kbd>user_id</kbd> which are together the primary key of that table.<br />
					If you keep to the defaults all you need to do is add <kbd>'users'</kbd> to the
					<kbd>$_many_many</kbd> static property of the Model_Post:</p>

				<pre class="php"><code>protected static $_many_many = array('users');</code></pre>

				<p>And you need to add a table like this one to your SQL:</p>

				<pre class="sql"><code>CREATE TABLE IF NOT EXISTS `posts_users` (
  `post_id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  PRIMARY KEY (`post_id`,`user_id`)
);</code></pre>

				<p>Below are examples for establishing and breaking has-many relations:</p>

				<pre class="php"><code>// both main and related object are new:
$post = new Model_Post();
$post->users[] = new Model_User();
$post->save();

// both main and related object already exist
$user = Model_User::find(8);
$user->posts[1] = Model_Post::find(1);
$user->save();

// break the relationship established above
$post = Model_Post::find(1);
unset($post->users[8]);
$post->save();</code></pre>

				<h3>Full config example with defaults as values</h3>

				<pre class="php"><code>// in a Model_Post which has and belongs to many Users
// = multiple posts per user and multiple users (authors) per post
protected static $_many_many = array(
	'users' => array(
		'key_from' => 'id',
		'key_through_from' => 'post_id', // column 1 from the table in between, should match a posts.id
		'table_through' => 'posts_users', // both models plural without prefix in alphabetical order
		'key_through_to' => 'user_id', // column 2 from the table in between, should match a users.id
		'model_to' => 'Model_User',
		'key_to' => 'id',
		'cascade_save' => true,
		'constraint' => \Orm\Relation::CONSTRAINT_SETDEFAULT,
	)
);</code></pre>

				<h3>A hybrid many-many relation</h3>

				<p>
					There are situations where you have a many-many relation between two tables, but you have values that are
					not a property of either table, but of the relation.
				</p>

				<p>
					An example of this could be a relation between "Recipes" and "Ingredients", where a recipe has multiple ingredients,
					and ingredients can be used in multiple recipes. But something like how much of an ingredient is needed in the recipe
					is a property of the relation between the two. In this case, you can define a hybrid relation between the two:
				</p>

				<pre class="php"><code>// recipe model relationship definitions
class Model_Recipe extends /Orm/Model
{
	protected static $_many_many = array(
		'ingredients' => array(
			'key_from' => 'id',
			'key_through_from' => 'recipe_id', // column 1 from the table in between, should match a recipe.id
			'table_through' => 'recipes_ingredients', // both models plural without prefix in alphabetical order
			'key_through_to' => 'ingredient_id', // column 2 from the through-table, should match an ingredient.id
			'model_to' => 'Model_Ingredient',
			'key_to' => 'id',
			'cascade_save' => true,
			'constraint' => \Orm\Relation::CONSTRAINT_SETDEFAULT, // don't delete the ingredients when deleting the recipe
		)
	);

	protected static $_has_many = array(
		'comments' => array(
			'key_from' => 'id',
			'model_to' => 'Model_RecipeIngredient',
			'key_to' => 'recipe_id',
			'cascade_save' => true,
			'constraint' => \Orm\Relation::CONSTRAINT_CASCADE, // delete the through table records on delete of the recipe
		)
	);
}

// ingredient model relationship definitions
class Model_Ingredient extends /Orm/Model
{
	protected static $_many_many = array(
		'recipes' => array(
			'key_from' => 'id',
			'key_through_from' => 'ingredient_id', // column 1 from the table in between, should match an ingredient.id
			'table_through' => 'recipes_ingredients', // both models plural without prefix in alphabetical order
			'key_through_to' => 'recipe_id', // column 2 from the through-table, should match a recipe.id
			'model_to' => 'Model_Ingredient',
			'key_to' => 'id',
			'cascade_save' => true,
			'constraint' => \Orm\Relation::CONSTRAINT_SETDEFAULT,  // don't delete the recipes when deleting the ingredient
		)
	);

	protected static $_has_many = array(
		'comments' => array(
			'key_from' => 'id',
			'model_to' => 'Model_RecipeIngredient',
			'key_to' => 'ingredient_id',
			'cascade_save' => true,
			'constraint' => \Orm\Relation::CONSTRAINT_CASCADE, // delete the through table records on delete of the ingredient
		)
	);

// through-table model relationship definitions
class Model_RecipeIngredient extends /Orm/Model
{
	protected static $_table_name = 'recipes_ingredients';

	protected static $_belongs_to = array(
		'recipe' => array(
			'key_from' => 'recipe_id',
			'model_to' => 'Model_Recipe',
			'key_to' => 'id',
			'cascade_save' => true,
			'constraint' => \Orm\Relation::CONSTRAINT_SETDEFAULT,
		),
		'ingredient' => array(
			'key_from' => 'ingredient_id',
			'model_to' => 'Model_Ingredient',
			'key_to' => 'id',
			'cascade_save' => true,
			'constraint' => \Orm\Relation::CONSTRAINT_SETDEFAULT,
		)
	);
}</code></pre>

				<p class="note">
					If you're just using it as a "through-table", that table doesn't have to have its own primary key, you could define a compound
					primary key for it, using both the "recipe_id" and "ingredient_id" properties. Although this works fine for the hybrid relationship
					too, you'll have to use <kbd>array('recipe_id', 'ingredient_id')</kbd> for the "key_from" of the "has_many", and "key_to" of the "belongs_to"
					relation definitions. Depending on your requirements it might be better to give the through table its own primary "id" key (as used in this example)
					and use unique indexes for the foreign keys.
				</p>

			</section>

		</div>

		<footer>
			<p>
				&copy; FuelPHP Development Team 2010-2025 - <a href="https://fuelphp.com">FuelPHP</a> is released under the MIT license.
			</p>
		</footer>
	</div>
</body>
</html>
